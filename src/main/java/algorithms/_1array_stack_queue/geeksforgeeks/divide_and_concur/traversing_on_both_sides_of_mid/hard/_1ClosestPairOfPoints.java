package algorithms._1array_stack_queue.geeksforgeeks.divide_and_concur.traversing_on_both_sides_of_mid.hard;

/*
Closest Pair of Points | O(n (log n)^2) Implementation
https://www.geeksforgeeks.org/closest-pair-of-points/

Closest Pair of Points | O(n log n) Implementation
https://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/

Youtube video:
https://www.youtube.com/watch?v=6UBDkbVhJck


This algorithm is hard because it is related to points scattered in 2-D plane.

IMPORTANT:
This algorithm is extremely important to understand 'divide & concur' concept and 'Back Tracking' strategy to find time complexity.

*/

public class _1ClosestPairOfPoints {
}
